python: 4차 산업 혁명 시대의 필수 언어..
- python은 확장성이 매우 강한 언어.
- python의 모듈로 들어오는 것들 하나하나가 마치 언어 같은 규모를 갖고 있습니다.
- 인공지능? 별도의 모듈을 학습
- 빅데이터? 별도의 모듈을 학습

일반적인 언어
float: 모든 언어에서 소수를 표현하기 위한 자료형..
자료형 변수명 = 자료형에 맞는 값;

R언어
변수명 = 값;


소수를 f 문자열 포매팅을 이용하기
입력
data = 3.14314314314
f'{data:0.4f}'   # 0은 자리수를 표현하지 않겟다는 뜻, 뒤에 4는 소숫점 4자리까지 나타나겟다는뜻, 
                    f는 float의 약자
출력
'3.1431'

입력
f'{data:10.2f}'
출력
'      3.14'

입력
f'{data:010.2f}'
출력
'0000003.14'

입력
f'{data:<10.2f}'
출력
'3.14      '

입력
f'{data:*<10.2f}'
출력
'3.14******'

######################
length
len약자

# 문자열과 관련된 함수

len( )
객체: 명사를 프로그래밍하여 메모리에 올려 놓은 것.

입력
a = "hello world"
len(a)
출력
11

입력
a.count('l')  # l 이 몇개 있는지 갯수나타냄, 
               # 객체명.함수명()
출력
3

입력
a.count('o')
출력
2

# 인덱스 반환하는 함수: find( )
입력
a.find('h')            a.find('e')
출력
0                      1

입력
print(a.find('l'))
print(a.find('z'))
출력
2
-1

입력
a.find('world')  # w의 인덱스번호를 반환해 준다
출력
6

hello 출력하기
# a의 값 중에서 hello world
입력
a[:a.find('world')]
출력
'hello '

# 인덱스 찾기2
입력
a.index('e')
출력
1

입력
a.index('z')  # 인덱스로 찾는데 없는 경우에는 에러가 뜬다
출력
찾을수 없다고 에러뜸


# ioin(): join()함수 안의 문자열을 더할 때, 구분자를 지정하게 해주는 기능
입력
",".join("hello")
출력
'h,e,l,l,o'

입력       " "안에 무엇을 넣는지에 따라 출력 값이 달라짐 
",".join(['a', 'b', 'c', 'd', 'a'])                     "".join(['a', 'b', 'c', 'd', 'a']) 
출력
'a,b,c,d,a'                                            'abcda'


# 파이썬에서 대소문자를 변경하는 함수를 찾아서 올려 주세요
입력
a = a.upper()
print(a)         # 대문자로 변경
출력
HELLO WORLD

입력
a.lower()       # 소문자로 변경
출력
'hello world'

입력
a
출력
'HELLO WORLD'

입력
a.islower()    # a에 들어 있는 값이 소문자가 맞나?
출력
False

입력
a.isupper()    # a에 들어 있는 값이 대문자가 맞나?
출력
True

입력
b = True   # 파이썬은 False, True 할땐, 첫글자만 대문자 처리한다


# 좌우공백 제거
입력
b = '          h    i         '
b
출력
'          h    i         '

입력
b.lstrip()   왼쪽제거
출력
'h    i         '

입력
b.rstrip()   오른쪽제거
출력
'          h    i'

입력
b.strip()    양쪽제거
출력
'h    i'

# 문자열 변경하기
c = "I am a man."
# man -> woman으로 변경하기
입력
c.replace("man", "woman")
출력
'I am a woman.'

입력
c   # c = c.replace("man", "woman") 안넣었기에 그대로 출력됨
출력
'I am a man.'


# 특정 기준(delim)으로 문자열 나누기
입력
d = "m001#kim#36#vip#4500"

d.split('#')  #출력에[ , , , ] 가 나타나는데 list 이다,
출력
['m001', 'kim', '36', 'vip', '4500']

입력
d_split = d.split('#')
d_split[2]   # [2] 넣어서 원하는 값을 뽑아낼수 있다
출력
'36'

입력
print(d_split[0], "님 환영합니다.")
출력
m001 님 환영합니다.

입력                      
type(d)      # 타입을 나타냄             type(d_split)     
출력 
str                                              list

##############################
# list 학습
# 데이터를 여러 개 묶을 수 있는 자료형
# list의 구조를 찾아 보세요.
# [ , , , , ] 이렇게 있으면 list이다

입력
a = [1, 3, 5, 7, 9]
type(a)
출력
list

# list()를 이용해서 list 생성하기
b = list()
c = [ ]        # 촐력값은 똑 같다 [ ] 나옴

입력
d = list([1, 2, 3, 4, 5])
d
출력
[1, 2, 3, 4, 5]

입력
b.append(1)    # 추가한다라는 뜻
b
출력
[1]

입력
b.append([2, 3])  
b
출력
[1, [2, 3]]


# 리스트의 인덱싱과 슬라이싱
입력
a
출력
[1, 3, 5, 7, 9]

입력
a[0]   # 1을 가지고 오기           a[4]   # 9를 가져오기
출력
1                                          9

입력
len(a)
출력
5

입력
a[len(a)-1]    # a[4] = a[5 - 1]
출력
9

입력
a[-1]
출력
9

입력
a[0] + a[-1]
출력
10

입력
a
출력
[1, 3, 5, 7, 9]

입력
a[1:3]
출력
[3, 5]

입력
a[:4]
출력
[1, 3, 5, 7]

입력
a[1:-1]        또는    a[1:4]
출력
[3, 5, 7]

##########
# 리스트 안에 리스트 넣기
e = [1, 2, 3, [4,5]]

입력
e[0]           e[3]             e[-1]
출력
1              [4, 5]           [4, 5]

# 리스트 안에 있는 리스트 뽑아냄
입력
f = e[3]                       
f[0]          ===>  e[3][0]   3번째 리스트 안에 있는 0번째 리스트
출력
4                       4

###
#문제
g = [[1, 2, 3], [4, 5, 6], [7, 8, 9], 0]

# 0 값 인덱싱하기
g[3] 또는 g[-1] 또는 g[len(g)-1]

# 변수 g에서 5만 추출하는 인덱싱 코드를 올려주세요
g[1][1]

############
# 리스트 연산
입력
a = [1, 1, 2, 2, 3, 3]
b = [9, 9]
a + b                                     a - b , a * b 는 요류뜸
출력
[1, 1, 2, 2, 3, 3, 9, 9]        


입력
a * 3
출력
[1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3]   3번 반복함

입력
len(a)
출력
6

숫자 + 문자
입력
a[1] + "good"      =>        str(a[1]) + "good"
출력 
오류뜸                =>       '1good'


# 인덱싱이 가능하다는 말은 xx도 가능하다.
# xx? 수정(변경)

# b=[9, 9]
# 인덱스가 1인 요솟값을 0으로 수정해 주세요
입력
b[1] = 0
b
출력
[9, 0]

# 최종 요솟값 삭제
# 리스트 b의 인덱스가 0인 최종 요솟값을 삭제하시오
입력
del(b[0])
b
출력
[0]

# del 요솟값과 변수를 삭제 했는데,
# remove를 이용해서 요솟값 삭제
b = [10, 20, 30, 40, 50, 60, 70, 10]
입력
b.remove(30)   # 인덱스가 아닌 값을 넣어야 한다
b              # 30이 삭제됨
출력
[10, 20, 40, 50, 60, 70, 10]

b.remove(10)
#1. 앞에 있는 10만 삭제됨
#2. 뒤에 있는 10만 삭제됨
#3. 둘 다 삭제됨
#4. 뭘 삭제할지 몰라서 삭제가 안 됨
b       # 실행하면 맨 앞에 있는 10만 삭제된다

출력
[20, 40, 50, 60, 70, 10]


# pop()함수를 이용해서 최종 요솟값 삭제
val = b.pop()    # b.pop()은 젤 끝에 있는 숫자부터 지정이 되서 요솟값이 삭제가 된다
print(val)
print(b)
출력
10
[20, 40, 50, 60, 70]

########
c = [1, 2, 3, 4, 5, 6, 7, 8, 10]
# 5 를 추출하는 코드를 올려주세요
입력
c[4]

# 3~7까지 추출하세요
c[2:7]

# 10을 삭제하세요   3가지를 배웠는데 그중 첫번째
del c[-1]
c

# 4를 삭제하는 코드 배운 순서대로 했을 때 2번째 삭제방법
c.remove(4)
c

# 8을 삭제하세요 3번째 배운걸로 
c.pop()
c

#########################
list( )함수를 이용해서 값이 있는 리스트를 만들 때는
list([1, 2]) 파라미터로 리스트를 넣어 줘야 합니다.

그런데 list의 append( )함수를 이용해서 요솟값을 추가할 때는
그냥 넣고자 하는 요솟값을 추가하면 됩니다.

입력
a = list()
type(a)
출력
list

입력
print(a)
출력
[ ]

입력
a.append(4)         a.append(True)        a.append("hello")         a.append(['a', 'b'])
a                      a                         a                             a
출력
[4]                    [4, True]                [4, True, 'hello']           [4, True, 'hello', ['a', 'b']]


# 리스트 안의 요솟값들에 대한 정렬
b = [10, 8, 1, 2, 9, 7]
b.sort()    # .sort() 오름차순으로 정렬하는 함수
b
출력
[1, 2, 7, 8, 9, 10]

# 역정렬: 현재 리스트의 최종 요솟값의  순서를 반대로..
b.reverse()
b
출력
[10, 9, 8, 7, 2, 1]


# 내림차순으로 하고 싶을 때
c = [5, 1, 3, 2, 8, 7, 6, 4]
c.sort()
c
c.reverse()           # .sort() 를 하고나서 .reverse() 를 다시 해준다
c
출력
[8, 7, 6, 5, 4, 3, 2, 1]

입력
c.index(8)   # 인덱스번호가 아닌 요솟값(데이터값)을 넣어줘야 한다
출력
0

입력
c.insert(0, 100)  # .insert() 끼워넣기 , 0이라는 인덱스번호에 숫자 100끼워넣기
c                 # 끼워 넣기는 컴터 성능을 저하시켜서 안쓰는게 좋다
출력
[100, 8, 7, 6, 5, 4, 3, 2, 1]

입력
c.pop(1)   이렇게해서 삭제가 가능하다
c
출력
[100, 7, 6, 5, 4, 3, 2, 1]

입력
x = c.pop(1)    이렇게해서 삭제가 가능하다
print(x)
print(c)
출력
7
[100, 6, 5, 4, 3, 2, 1]

입력 
d = [1, 2]                  
e = [3, 4]                  
d + e                        d.extend(e)    # d = d + e 하고 같은 기능이다  
출력                         d
[1, 2, 3, 4]

#################
튜플...

변수: 값을 바꿀 수 있는 메모리 이름
변하는 데이터를 담을 수 있는 메모리 이름

상수: 항상 같은 값만 갖고 있는 메모리 이름

변수 vs 상수 차이
변수: 값이 변한다.
상수: 값이 항상 같으니깐 변하지 않는다.

# tuple 학습
# list와 거의 같음.
# 그러나 tuple 객체가 생성된 후에는 값을 추가/수정/삭제 할 수 없음.


튜플:
- ( )에 값을 적습니다.
- 값이 1개일만 때는 반드시 값을 입력하고 , 를 찍습니다.
- 값이 2개 일때는 찍어도 안찍어도 상관없다.  1개 일때만 조심하자!!
- 경우에 따라 ( )를 생략해도 된다.
- 튜플의 요솟값은 수정/삭제/추가 불가하다

a_list = [1, 2, 3, 4, 5]
a_list[0] = 100
print(a_list)
출력
[100, 2, 3, 4, 5]

a_list.remove(100)
a_list
출력
[2, 3, 4, 5]

a = ()
a
출력
( )

b = (1)
b[0] 
출력
값이 없다고 에러뜸

b2 = (1, )           b3 = (1, 2)          b4 = (1, 2, )
b2[0]                 b3[1]                 b4[1]
출력
1                      2                      2


c = 1, 2, 3, 4, 5
c[1]
출력
2

c[1] = 1000  # 튜플은 값을 변경하는데 사용할 수없다고 에러뜸
출력
에러뜸

type(c)
출력
tuple

######################중요함##############
dictionary(딕셔너리): java map과 같음.
상자와 같은 역할: 여러 개의 데이터를 저장할 수 있음.
list 나 tuple 와 확연하게 다른 점은,
index가 없음.
index는 자동으로 만들어짐
index는 반드시 정수로 만들어짐
대신
dictionary를 사용하는 사람이 
index와 같은 개념의 key를 만듦.
해당 key에 대응하는 값을 입력함.
구조는  { : }
{ key : val1. key2 : val2, key3 : val3 }

언제 사용하나?
하나의 객체(사물)을 데이터로 표현할 때 사용함.
{"id":"m001", "name":"홍길동", "age":16}  {키:값, 키:값, 키:값}  

hong = {"id" : "m001", "name" : "홍길동", "age" : 16} # 정말 숫자는 ""를 붙이지 않고 문자일때는 붙인다
hong
출력
{'id': 'm001', 'name': '홍길동', 'age': 16}

phone = {"제조사":"삼성", "모델":"갤럭시S4 액티브", "가격":"80만원"}
phone
출력
{'제조사': '삼성', '모델': '갤럭시S4 액티브', '가격': '80만원'}

# 여러개 넣고 싶을때, 가능하면 구조가 비슷하게 넣는게 좋다
home = {"tv":["삼성", "80인치", "300만원"], "냉장고":["LG", "150L", "100만원", 1 : "hello"]} 
home                                                                                           정수도 가능하다
출력
{'tv': ['삼성', '80인치', '300만원'], '냉장고': ['LG', '150L', '100만원'], 1 : 'hello'}

phone['제조사']     phone['모델']            phone['가격']      
출력
'삼성'                  '갤럭시S4 액티브'       '80만원'           

home[1]       home['tv']
출력
'hello'          ['삼성', '80인치', '300만원']

home['tv'][1]        home['tv'][2]  # 300만원을 출력하는 코드는?
출력
'80인치'              '300만원'

# home에서 냉장고와 관련된 정보를 전부 하나씩 출력하시오
print(home['냉장고'][0])
print(home['냉장고'][1])
print(home['냉장고'][2])
출력
LG
150L
100만원

#추가하기
home["pc"] = "삼성노트북"                    home["rnd"] = 333    
home                                                home
출력
{'tv': ['삼성', '80인치', '300만원'],              {'tv': ['삼성', '80인치', '300만원'],                           
 '냉장고': ['LG', '150L', '100만원'],              '냉장고': ['LG', '150L', '100만원'],                              
 1: 'hello',                                            1: 'hello',                             
 'pc': '삼성노트북'}                                 'pc': '삼성노트북',
                                                        'rnd': 333}                                      

#변경하기
home["pc"] = "삼성 데스크톱"
home
출력
{'tv': ['삼성', '80인치', '300만원'],
 '냉장고': ['LG', '150L', '100만원'],
 1: 'hello',
 'pc': '삼성 데스크톱',
 'rnd': 333}

#삭제하기
del home['rnd']           
home
출력
{'tv': ['삼성', '80인치', '300만원'],
 '냉장고': ['LG', '150L', '100만원'],
 1: 'hello',
 'pc': '삼성 데스크톱'}

#########
key는 중복을 허용하지 않습니다
값은 중복을 허용한다
member = {"id":"m001", "id":"홍길동", "id":16}
meber['id']

만약 id 하나에 넣고 싶을때
member = {id : ["m001", "홍길동", 16]}
member 
출력
{<function id(obj, /)>: ['m001', '홍길동', 16]}


컬럼 단위로 코드 짜는게 좋다
id    name   age
m1   kim      16
m2   lee       19
m3   park     60
입력
people = {'id' : ['m1','m2','m3'],               이렇게 작성하는건 빅데이터에 최적화다
          'name' : ['kim','lee','park'], 
          'age' : [16,19,60]}
people
출력
{'id': ['m1', 'm2', 'm3'], 'name': ['kim', 'lee', 'park'], 'age': [16, 19, 60]}

people['name'][0]           people['id'][0]          people['age'][0]
출력
'kim'                          'm1'                      16


또는
people2 = [                                                이렇게 작성하는건 DB 쪽에서 사용된다
    {"id":"m1", "name":"kim", "age":16},
    {"id":"m2", "name":"lee", "age":19},
    {"id":"m3", "name":"park", "age":60}
]
people2
출력
[{'id': 'm1', 'name': 'kim', 'age': 16},
 {'id': 'm2', 'name': 'lee', 'age': 19},
 {'id': 'm3', 'name': 'park', 'age': 60}]

people2[0]["id"]
출력
'm1'


# keys() : 키 목록을 반환해주는 함수
people
{'id': ['m1', 'm2', 'm3'], 'name': ['kim', 'lee', 'park'], 'age': [16, 19, 60]}

hong
{'id': 'm001', 'name': '홍길동', 'age': 16}

hong.keys()
dict_keys(['id', 'name', 'age'])


# 파이썬은 for문에서 선언된 변수가 for문 밖에서도 인식이 됨
hong[key]
출력
16

# 딕셔너리val(밸류)의 목록 가져오기
hong.values()
출력
dict_values(['m001', '홍길동', 16])

for val in hong.values():
    print(val)
출력
m001
홍길동
16

print(val)
출력
16

val_list = list()
for val in hong.values():
    val_list.append(val)
    print(val)
출력
m001
홍길동
16

print(val_list)
출력
['m001', '홍길동', 16]


hong.items()
출력
dict_items([('id', 'm001'), ('name', '홍길동'), ('age', 16)])

print("before: ", hong)
hong.clear()
print("after: ", hong)    # 출력값에 after:  {} 빈 값만 들어 있다. 아예 사라진거는 아니다
출력
before:  {'id': 'm001', 'name': '홍길동', 'age': 16}
after:  { }














