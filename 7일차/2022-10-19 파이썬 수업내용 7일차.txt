1. 데이터 웨어하우스
- 일반적으로 데이터는 흩어져 있습니다.
- 흩어져 있는 데이터를 전사적(모든 부서)으로 수집하고 
  동일한 구조로 관리하여 사용자의 의사결정에 도움을 주기 위한 데이터베이스
 - 데이터가 산재되어 있다는 말은 데이터가 분산되어 있다는 말과 다름
 - 데이터 산재: 방치, 사관들이 각자 작성한 사초를 자신이 갖고 있는 모습
 - 데이터 웨어하우스: 사관들이 갖고 있는 사초를 다 수집합니다. 정해진 양식에 따라 사초를 정리해서 실록으로 편찬
 - 데이터 분산: 잘 관리 되어 있는 데이터를 안전하게 보관하게 하기 위해서 여러군데에 저장하는 것.
 - 조선왕조실록

2. 데이터 마트
- 데이터 웨어하우스에서
- 특정 조직이 필요로 하는 특정 기능의 데이터만을 추출한 것.

3. 데이터 마이닝
- 데이터에서 유의미한 정보를 획득하는 작업    

########
R에서 웹크롤링하기 위해서 사용한 툴(도구)가 뭐였죠?
selenium: 원래는 테스트 자동화 툴(도구)

개발을 하다 보면, 한번에 성공하는 경우도 있겠지만 그렇지 않은 경우가 있습니다.
결함을 수정을 함.
결함이 제거 되었는지 테스트를 해야 함.
그 테스팅을 뭐라고 하냐면,
==
확인테스팅 : 결함을 수정한 후 결함이 제거 되었는지에 대한 테스트
==
아주 잘 돌아가는 프로그램이 있습니다.
정말 잘 돌아감.
예전에 이미 테스트 다 완료된 프로그램...
근데
그 프로그램의 내용 중 일부를 수정을 합니다.
기존 a = a+1
수정 a += 1 => a = a+1
1. 잘 돌아가는 프로그램이니까 별도의 테스트는 필요 없다. (X)
2. 뭔 소리여. 코드가 수정 됐으면 무조건 테스트를 해야지. (O)
테스트를 해야 하는데,
이런 상황에서 실시하는 테스트를 회귀테스팅
==
회귀테스팅: 정상적인 프로그램을 수정한 후 결함이 있는지 여부를 확인하는 테스팅
==

#########
테스트를 그냥 막하지 않음.
- 테스트를 할 때, 문서를 작성해서 합니다. 어떤 것에 대한 테스트인지,

테스트 케이스: 확인해야 하는 특정 기능이나 모듈, 프로그램 수행 경로를 실행하거나 요구사항에 준수하는
                  확인하기 위한 테스트 과정과 이때 사용되는 입력값, 예상값을 정의한 문서..
- 테스트 단계
- 테스트 절차
- 테스트에 사용할 입력값
- 테스트 결과 예측값

test1.py 모듈이 있었는데 그 안에 있는 plus( ) 함수를 테스트를 한다고 가정하면.. 이것 테스트하려면
어떻게 테스트해야죠?
- from test1 import plus
  plus3()

테스트 시나리오: 테스트 케이스의 집합

====
데이터 웨어하우스
데이터 마트
데이터 마이닝
테스트 자동화 도구(툴)
확인테스팅
회귀테스팅
v모델의 단계별 테스트 분류
시스템 테스트: 기능/비기능 테스트도 한다.
테스트 케이스: 테스트 단계, 테스트 절차, 입력값, 예상되는 결과값
테스트 시나리오

#################################
# numpy를 np라는 별칭으로 import 하세요
import numpy as np
data1 = [x for x in range(1, 10)]
data1
출력
[1, 2, 3, 4, 5, 6, 7, 8, 9]

data2 = list(range(0, 10))
data2
출력
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# list를 이용해서 numpy의 array를 생성함
arr1 = np.array(data1)
arr1
출력
array([1, 2, 3, 4, 5, 6, 7, 8, 9])

arr2 = np.array(data2)
arr2
출력
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

arr1.shape
출력
(9,)

arr2.shape
출력
(10,)

arr3 = np.array(
[
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 0, 1, 2]
]
)
arr3.shape
출력
(3, 4)

arr4 = np.array(
[
    [
        [
            [1, 2]
        ],
        [
            [3, 4]
        ],
        [
            [5, 6]
        ]
    ],
    [
        [
            [7, 8]
        ],
        [
            [9, 0]
        ],
        [
            [1, 2]
        ]
    ]
 
]
)
arr4.shape
출력
(2, 3, 1, 2)

arr1.dtype       arr2.dtype    arr3.dtype    arr4.dtype
출력
전부 다 dtype('int32') 이다

arr5 = np.array([3, 14, 9.8, 5, 1.0])
arr5.dtype
출력
dtype('float64')

arr1.ndim   # ndim 몇 차원 인지를 알려준다
출력
1

arr2.ndim     arr3.ndim       arr4.ndim      arr5.ndim
출력
1               2                 4                 1

arr6 = np.array([0, 0, 0, 0, 0])
arr6
출력
array([0, 0, 0, 0, 0])

arr7 = np.zeros(100)
arr7
출력
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

arr7.shape
출력
(100,)

arr8 = np.zeros((4, 25))
arr8.shape
출력
(4, 25)

arr8
출력
array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
        0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
        0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
        0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
        0., 0., 0., 0., 0., 0., 0., 0., 0.]])

# arr9는 numpy의 array로 이루어진 변수인데,
# 그안에 1만 들어 있음
# 만들어 보세요
# 개수는 100개 , 1차원
arr9 = np.ones(100)
arr9
출력
array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])

data3 = [x for x in range(10)]
arr10 = np.array(data3)
arr10
출력
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

# 더 간단하게 작성하려면..
arr11 = np.arange(10)
arr11
출력
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

######
numpyex3

# arange()함수를 이용해서 numpy의 array arr1을 생성하시오. 0~11
import numpy as np
arr1 = np.arange(12)
arr1
출력
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

arr1.shape
출력
(12,)

arr2 = arr1.reshape(3, 4)
arr2
출력
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

# 다시 1차원이며 요솟값이 11까지 들어가게 만들어라.
arr3 = arr2.reshape(12)
arr3
출력
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

arr4 = np.ones((4, 2))
arr4
출력
array([[1., 1.],
       [1., 1.],
       [1., 1.],
       [1., 1.]])

# 구조는 특정 배열의 구조를 따라가고, 최종 요솟값은 0 또는 1을 넣고 싶을 때
arr5 = np.ones_like(arr2) 
arr5
출력
array([[1, 1, 1, 1],
       [1, 1, 1, 1],
       [1, 1, 1, 1]])

# arr6은 최종 요솟값이 전부 0으로 채워져 있음
# 구조는 arr2와 같은
# arr6을 생성하시오
arr6 = np.zeros_like(arr2)
arr6
출력
array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]])

arr6 = np.zeros_like(arr2, dtype=float)    # dtype=int 를 넣어서 자기가 원하는 데이터 타입을 정하면 된다    
arr6   # 출력을 보면 0옆에 .이 찍힌다
출력
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

# numpy의 array => 행렬
# 주대각행렬을 만들기 위해 인덱싱을 하지 말고, identity()함수를 이용하자.
arr7 = np.identity(3)    # identity을 이용하면 주대각행렬을 만들수 있다
arr7
출력
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
# 정사각행렬  
# n x m 
# n = m
# array에서는
# 2차원 배열에 들어 있는 1차원 배열의 수와
# 1차원 배열에 들어 있는 최종 요솟값의 수
# 같을 때
# 주대각선 행렬

# 대각행렬을 만들 때, 주대각행렬이 아닌 대각행렬을 만들고 싶을 때는, eye()함수를 이용
arr8 = np.eye(3)
arr8
출력
array([[1., 0., 0.],    1의 위치를 잘 보아라 
       [0., 1., 0.],
       [0., 0., 1.]])

arr9 = np.eye(3, k=1)
arr9
출력
array([[0., 1., 0.],    1의 위치가 주대각선이 아닌 위쪽에 있다
       [0., 0., 1.],
       [0., 0., 0.]])

arr10 = np.eye(3, k=-1)
arr10
출력
array([[0., 0., 0.],    -1의 위치가 주대각선이 아닌 아래쪽에 있다
       [1., 0., 0.],
       [0., 1., 0.]])

arr11 = np.empty((2, 2))   # 임의값 아무거나 넣고 싶을때 empty()함수를 사용한다
arr11                      # 2,3 대신 숫자를 바꾸면 임의값이 변한다
출력
array([[6.43180438e-312, 6.95200451e-310],
       [4.94065646e-324,             nan]])

########
# 정리..
# 1. 리스트를 이용해서 numpy의 array를 생성(행렬)
# - array()

# 2. numpy의 array 구조를 확인하기 위해서
# - arr1.shape

# 3. numpy의 최종 요솟값의 자료형 확인위해
# - arr1.dtype

# 4. numpy의 array 차원을 확인하기 위해
# - arr1.ndim

# 5. 간편하게 array를 생성하기 위해서
# - np.arange()

# 6. 기존 array의 구조와 같은 array를 만들기 위해
# - arr2 = np.reshape(2, 3)

# 7. 1로만 가득 채워진 array를 만들기 위해서
# - arr3 = np.ones( (2, 3) )

# 8. 0으로만 가득 채워진 array를 만들기 위해서
# - arr4 = zeros( (2, 3) )

# 9. 구조는 다른 array 것과 똑같이 하면서, 값은 0이나 1로 채우고 싶을 떄
# - arr5 = ones_like( arr4 )
# - arr6 = zeros_like( arr4 ) 

# 10. 주대각정사각행렬
# - np.identity(3)    3x3array가 만들어 짐

# 11. 대각정사각행렬
# - np.eye(3, k=1)

# 12. 임의의 값으로 채워지는 array를 생성
# - arr7 = np.empty( (3, 2) )

#####
numpyex4

import numpy as np

# 넘파이 어레이 배열 객체 2를 만들고
# 이 두객체에 대해서 +, -, *, / 연산을 하세요.


# arr1 * 10을 하고 결과 확인: 브로드캐스팅(크기가 달라도 연산이 가능하다)






























































