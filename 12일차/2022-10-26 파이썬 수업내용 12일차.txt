# first.csv 파일이 있습니다
# 불러와서 df1 변수에 할당하세요
import numpy as np
import pandas as pd

df1 = pd.read_csv('first.csv')
df1.head()
# 만약 first.csv의 파일이 다른폴더(data폴더) 안에 있을 경우
# 경로를 data/first.csv 적으면 된다.
# 또 만약에 pandasex4 다른 폴더에 있을 경우
# 경로를 상대경로(경로가 바뀔수 있음) : python_workspace/data/first.csv
# .. 상위 폴더  
# 절대경로(경로가 절대 바뀌지 않음) : C:\Users\admin\python_workspace/data/first.csv

출력
      Unnamed: 0	id	addr	name
0	0	1	서울	kim
1	1	2	서울	lee
2	2	3	제주	park
3	3	4	강원	jung

# Unnamed: 0 컬럼을 제거해 주세요
df1.drop('Unnamed: 0', axis = 1, inplace = True)
df1.head()
출력
	id	addr	name
0	1	서울	kim
1	2	서울	lee
2	3	제주	park
3	4	강원	jung

# 인덱스를 zero one two three로 변경해 주세요
df1.index = ['zero', 'one', 'two', 'three']     실무에서는 이 방법을 많이 사용함
df1.head()

# 또는 
# df1.rename(index={0:'zero', 1:'one', 2:'two', 3:'three'}, inplace=True)
# df1.head()
출력
	id	addr	name
zero	1	서울	kim
one	2	서울	lee
two	3	제주	park
three	4	강원	jung

# 컬럼명 변경하기
# 아이디  주소 이름
df1.rename(columns={'id':'아이디', 'addr':'주소', 'name':'이름'}, inplace=True)
df1.head()
# 또는
# df1.columns = ['아이디', '주소', '이름']
# df1.head()
출력
	아이디	주소	이름
zero	1	서울	kim
one	2	서울	lee
two	3	제주	park
three	4	강원	jung

# 문제 출제를 위해 다시 복구
df1.columns=['id', 'addr', 'name']
df1.head()

# df1에 있는 모든 id 컬럼 값을 추출하시오
df1[['id']]   # 실무에서는 데이터프레임으로 사용함
# 또는 
# df1['id'] 시리즈로 나타낼수도 있음
# 또는
df1.filter(regex='id')
출력
	id
zero	1
one	2
two	3
three	4

# first3.csv를 읽어 와서
# df2에 할당하세요
df2 = pd.read_csv('first3.csv', header = None)
df2.head()
출력
           0	1	2
0	1	서울	kim
1	2	서울	lee
2	3	제주	park
3	4	강원	jung

# df2의 컬럼명을 id, addr, name 으로 변경해 주세요
df2.columns = ['id', 'addr', 'name']
df2.head()
# 또는
# df2.rename(columns={0:'id', 1:'addr', 2:'name'}, inplace=True)
# df2.head()
출력
           id	addr	name
0	1	서울	kim
1	2	서울	lee
2	3	제주	park
3	4	강원	jung

# 인덱스가 zero인 row(행) 추출하기
df1.loc[['zero']]  # 데이터프레임으로 나옴
# 또는 
# df1.loc['zero'] 시리즈로 나옴
출력
	id	addr	name
zero	1	서울	kim

# row의 인덱스 zero, 컬럼 id, addr만 나오게 추출하세요
# loc
df1.loc['zero', ['id', 'addr']]

# row의 인덱스 zero, 컬럼 id, addr만 나오게 추출하세요
# iloc
df1.iloc[0, 0:1]

# 별개로함
df1.iloc[0:1, 0:2]
출력
	id	addr
zero	1	서울

# df1의 행 중에서 인덱스 0인 것과 2인 것만 추출하세요
df1.iloc[[0,2]]
# 또는
# df1.loc[[0,2]]
출력
	id	addr	name
zero	1	서울	kim
two	3	제주	park

# df1의 행 중에서 인덱스 0인 것과 2인 것만 추출하고
# column은 id, name만 추출하세요
df1.iloc[[0, 2], [0, 2]]
# 또는
# df1.loc[['zero', 'two'], ['id', 'name']]
출력
	id	name
zero	1	kim
two	3	park

# id가 3 이상인 행만 출력하세요
df1[df1['id'] >= 3]
출력
	id	addr	name
two	3	제주	park
three	4	강원	jung

# df1, df2가 있음
# 병합을 한다면
# 세로방향으로 병합해야 할까요?, 가로 방향으로 병합해야 할까요?
# 세로방향임

# df1 과 df2를 세로 방향으로 병합해 주세요
df3 = pd.concat([df1, df2], axis=0, ignore_index=True)
df3.head()
# axis=0 세로방향,   axis=1 가로방향
출력
	id	addr	name
0	1	서울	kim
1	2	서울	lee
2	3	제주	park
3	4	강원	jung
4	1	서울	kim

###############
df4 = {
    'age' : [10, 20, 30, 40, 50, 60, 70]
}
df4 = pd.DataFrame(df4)
df4
출력
          age
0	10
1	20
2	30
3	40
4	50
5	60
6	70

# df3 과 df4를 병합한다면, 가로방향으로 병합할까요?, 세로방향으로 병합할까요?
# 가로방향임 

# df3 과 df4를 가로방향으로 병합해주세요
result = pd.concat([df3, df4], axis=1)
result
출력
           id	addr	name	age
0	1	서울	kim	10.0
1	2	서울	lee	20.0
2	3	제주	park	30.0
3	4	강원	jung	40.0
4	1	서울	kim	50.0
5	2	서울	lee	60.0
6	3	제주	park	70.0
7	4	강원	jung	NaN

df5 = pd.DataFrame({
    'id':['m1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8'],
    'salary':[3000, 4000, 3000, 5000, 6000, 4000, 3000, 9000]
})
df5
출력
           id	salary
0	m1	3000
1	m2	4000
2	m3	3000
3	m4	5000
4	m5	6000
5	m6	4000
6	m7	3000
7	m8	9000

# result와 df5를 가로 병합하세요, 병합 후에 result2에 그 결과를 할당하세요
result2 = pd.concat([result, df5], axis=1, ignore_index=True) 
result2.head()
# 컬럼명이 중복이 되기때문에 ignore_index=True 입력해서 초기화시키고 
# 다시 columns를 이용해서 넣어준다
출력
	0	1	2	3	4	5
0	1	서울	kim	10.0	m1	3000
1	2	서울	lee	20.0	m2	4000
2	3	제주	park	30.0	m3	3000
3	4	강원	jung	40.0	m4	5000
4	1	서울	kim	50.0	m5	6000

result2.columns=['id', 'addr', 'name', 'age', 'nickname', 'salary']
result2.head()
출력
	id	addr	name	age	nickname	salary
0	1	서울	kim	10.0	m1	3000
1	2	서울	lee	20.0	m2	4000
2	3	제주	park	30.0	m3	3000
3	4	강원	jung	40.0	m4	5000
4	1	서울	kim	50.0	m5	6000

result2.fillna(0, inplace=True)
# fillna는 널 값을 채워주세요 라는 의미

result2 = result2.astype({'age':'int'})
result2
# astype 타입을 이형태로 바꿔주세요 라는 의미
출력
	id	addr	name	age	nickname	salary
0	1	서울	kim	10	m1	3000
1	2	서울	lee	20	m2	4000
2	3	제주	park	30	m3	3000
3	4	강원	jung	40	m4	5000
4	1	서울	kim	50	m5	6000
5	2	서울	lee	60	m6	4000
6	3	제주	park	70	m7	3000
7	4	강원	jung	0	m8	9000

# age가 0이면, nan 처리하세요
result2.replace(0, np.NaN)
# 바뀌면서 age가 자료형으로 바뀜
# 또는
# result2[result2['age'].isna()['age']] = 0
출력
	id	addr	name	age	nickname	salary
0	1	서울	kim	10.0	m1	3000
1	2	서울	lee	20.0	m2	4000
2	3	제주	park	30.0	m3	3000
3	4	강원	jung	40.0	m4	5000
4	1	서울	kim	50.0	m5	6000
5	2	서울	lee	60.0	m6	4000
6	3	제주	park	70.0	m7	3000
7	4	강원	jung	NaN	m8	9000

result2.describe()
출력
	id	age	           salary
count	8.000000	8.000000	           8.000000
mean	2.500000	35.000000	4625.000000
std	1.195229	24.494897	2065.879266
min	1.000000	0.000000  	3000.000000
25%	1.750000	17.500000	3000.000000
50%	2.500000	35.000000	4000.000000
75%	3.250000	52.500000	5250.000000
max	4.000000	70.000000	9000.000000

# salary의 std(표준편차)를 추출하세요
result2.describe().loc['std', 'salary']
또는
result2.describe().iloc[2, 2]
출력
2065.879266282796

# 또는
result2.describe()[2:3]['salary']
출력
std    2065.879266
Name: salary, dtype: float64

# result2를 python_workspace 폴더에 result.csv로 지정하세요
result2.to_csv('result2.csv', index=False)

result2['addr'].value_counts()
출력
서울    4
제주    2
강원    2
Name: addr, dtype: int64

result2['addr'].unique()  # 하나씩만 나오게 하기
출력
array(['서울', '제주', '강원'], dtype=object)

result2.duplicated('addr')
# 중복이 되면 True, 중복이 안됫으면 False
출력
0    False
1     True
2    False
3    False
4     True
5     True
6     True
7     True
dtype: bool

result2.drop_duplicates(['addr'], keep='first')
# 중복 안된 데이터가 출력이 된다
출력
	id	addr	name	age	nickname	salary
0	1	서울	kim	10	m1	3000
2	3	제주	park	30	m3	3000
3	4	강원	jung	40	m4	5000

#########
result2.duplicated('addr')
result2['addr'].duplicated()  비교 차이점

result2.duplicated('addr')
# 전체 데이터에서 addr 중복이 있는지 판단한다
# dtype: bool
출력
0    False
1     True
2    False
3    False
4     True
5     True
6     True
7     True
dtype: bool

result2['addr'].duplicated()
# addr 데이터에서만 중복이 있는지 판단한다
# Name: addr, dtype: bool
출력
0    False
1     True
2    False
3    False
4     True
5     True
6     True
7     True
Name: addr, dtype: bool

######################
pandasex5 생성

import numpy as np
import pandas as pd

np.random.seed(0)
df1 = pd.DataFrame(np.random.randn(7, 4))
df1
출력
	0	1	2	3
0	1.764052	0.400157	0.978738	2.240893
1	1.867558	-0.9772780.950088	-0.151357
2	-0.1032190.410599	0.144044	1.454274
3	0.761038	0.121675	0.443863	0.333674
4	1.494079	-0.2051580.313068	-0.854096
5	-2.5529900.653619	0.864436	-0.742165
6	2.269755	-1.4543660.045759	-0.187184

# 컬럼 a, b, c, d로 넣어 주세요
df1.columns = ['a', 'b', 'c', 'd']
df1
출력
	a	b	c	d
0	1.764052	0.400157	0.978738	2.240893
1	1.867558	-0.9772780.950088	-0.151357
2	-0.1032190.410599	0.144044	1.454274
3	0.761038	0.121675	0.443863	0.333674
4	1.494079	-0.2051580.313068	-0.854096
5	-2.5529900.653619	0.864436	-0.742165
6	2.269755	-1.4543660.045759	-0.187184

# 인덱스에 날짜 넣기
df1.index = pd.date_range('20221026', periods=7)
df1
출력                         
                          a	    b	    c	    d
2022-10-26	1.764052	0.400157	0.978738	2.240893
2022-10-27	1.867558	-0.9772780.950088	-0.151357
2022-10-28	-0.1032190.410599	0.144044	1.454274
2022-10-29	0.761038	0.121675	0.443863	0.333674
2022-10-30	1.494079	-0.2051580.313068	-0.854096
2022-10-31	-2.5529900.653619	0.864436	-0.742165
2022-11-01	2.269755	-1.4543660.045759	-0.187184

df2 = pd.DataFrame(np.random.randn(1, 4), columns = ['a', 'b', 'c', 'd'])
df2
출력
                a	                 b	                  c	               d
0	-0.887786	-1.980796	-0.347912	0.156349

# df1, df2 병합하기
df3 = pd.concat([df1, df2], axis=0, ignore_index=True)
df3
출력
	      a	     b	    c	    d
0	1.764052	0.400157	0.978738	2.240893
1	1.867558	-0.9772780.950088	-0.151357
2	-0.1032190.410599	0.144044	1.454274
3	0.761038	0.121675	0.443863	0.333674
4	1.494079	-0.2051580.313068	-0.854096
5	-2.5529900.653619	0.864436	-0.742165
6	2.269755	-1.4543660.045759	-0.187184
7	-0.887786-1.980796-0.3479120.156349


# df3의 인덱스를 20221026부터 날짜 데이터로 바꾸어 주세요.
df3.index = pd.date_range('20221026', periods=8)
df3
또는
df3.index = pd.date_range('20221026', periods=len(df3))              len(df3)
df3                                                                              출력 8
출력
	                 a	    b	    c	   d
2022-10-26	1.764052	0.400157	0.978738	2.240893
2022-10-27	1.867558	-0.9772780.950088	-0.151357
2022-10-28	-0.1032190.410599	0.144044	1.454274
2022-10-29	0.761038	0.121675	0.443863	0.333674
2022-10-30	1.494079	-0.2051580.313068	-0.854096
2022-10-31	-2.5529900.653619	0.864436	-0.742165
2022-11-01	2.269755	-1.4543660.045759	-0.187184
2022-11-02	-0.887786-1.980796-0.3479120.156349

pd.to_datetime('20221027')
# Timestamp 라는 자료형 데이터가 나옴
출력
Timestamp('2022-10-27 00:00:00')

# date 인덱스가 2022-11-01인 행 정보를 추출하세요
df3.loc[['2022-11-01']]
출력
                            a	     b	     c	     d
2022-11-01	2.269755	-1.4543660.045759	-0.187184

df3.loc[['2022-11-01'], ['a', 'b']]
출력
	                 a	     b
2022-11-01	2.269755	-1.454366

df3.loc[['20221026', '2022-11-01'], ['a', 'b']]
출력
	                a	    b
2022-10-26	1.764052	0.400157
2022-11-01	2.269755	-1.454366

df3['e'] = [1, 2, np.nan, 4, 5, None, 7, 8]
df3
	                 a	    b	    c	   d	 e
2022-10-26	1.764052	0.400157	0.978738	2.240893	 1.0
2022-10-27	1.867558	-0.9772780.950088	-0.151357 2.0
2022-10-28	-0.1032190.410599	0.144044	1.454274  NaN
2022-10-29	0.761038	0.121675	0.443863	0.333674	 4.0
2022-10-30	1.494079	-0.2051580.313068	-0.854096 5.0
2022-10-31	-2.5529900.653619	0.864436	-0.742165 NaN
2022-11-01	2.269755	-1.4543660.045759	-0.187184 7.0
2022-11-02	-0.887786-1.980796-0.3479120.156349	 8.0

df3.isnull()  또는  df3.isna()
출력
	             a	b	c	d	e
2022-10-26	False	False	False	False	False
2022-10-27	False	False	False	False	False
2022-10-28	False	False	False	False	True
2022-10-29	False	False	False	False	False
2022-10-30	False	False	False	False	False
2022-10-31	False	False	False	False	True
2022-11-01	False	False	False	False	False
2022-11-02	False	False	False	False	False

df3['e'].isna()
출력
2022-10-26    False
2022-10-27    False
2022-10-28     True
2022-10-29    False
2022-10-30    False
2022-10-31     True
2022-11-01    False
2022-11-02    False
Freq: D, Name: e, dtype: bool

# 컬럼 e의 값이 NaN인 행을 추출하시오
df3[df3['e'].isna()]
출력
                            a	      b	    c	    d	  e
2022-10-28	-0.1032190.410599	0.144044	1.454274	NaN
2022-10-31	-2.5529900.653619	0.864436	-0.742165NaN

# NaN인지 여부를 확인하려면,
# 반드시
# isna(), isnull()만 사용해야 한다.

# df3.notna(), df3.notnull()
# df3의 컬럼 e의 값이 NaN이 아닌 행을 추출하시오
df3[df3['e'].notna()]
출력
	                a	   b	   c	   d	e
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0
2022-11-02	-0.887786-1.980796-0.3479120.156349	8.0

# df3[df3['e'].notna()] 에서 컬럼이 a,c,e만 추출되게 하세요
df3[df3['e'].notna()][['a', 'c', 'e']]

# loc를 사용하면
df3.loc[df3['e'].notnull(), ['a', 'c', 'e']]

출력
	                a	    c	e
2022-10-26	1.764052	0.978738	1.0
2022-10-27	1.867558	0.950088	2.0
2022-10-29	0.761038	0.443863	4.0
2022-10-30	1.494079	0.313068	5.0
2022-11-01	2.269755	0.045759	7.0
2022-11-02	-0.887786-0.3479128.0

# 삭제하기
df3.drop('20221102')
출력
	               a	b	c	d	e
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-28	-0.1032190.410599	0.144044	1.454274	NaN
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-10-31	-2.5529900.653619	0.864436	-0.742165NaN
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0

# 어떤 행이든지 NaN 값이 있으면 그 행 전체가 삭제된다
df3.dropna(how='any')
출력
	                 a	b	c	d	e
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0
2022-11-02	-0.887786-1.980796-0.3479120.156349	8.0

# 모든 값이 NaN 이면 삭제해라
df3.dropna(how='all')
출력
	a	b	c	d	e
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-28	-0.1032190.410599	0.144044	1.454274	NaN
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-10-31	-2.5529900.653619	0.864436	-0.742165NaN
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0
2022-11-02	-0.887786-1.980796-0.3479120.156349	8.0


# NaN 제외한 평균값
df3['e'].mean(skipna=True) # NaN 제외한 값을 평균값
출력
4.5

# NaN 포함한 평균값
df3['e'].mean(skipna=False)
출력
nan

# NaN인 곳에다 값을 집어 넣기
df3.fillna(0)

# df3.fillna(df3['e'].mean()) 도 넣을 수 있다
출력
	                 a	b	c	d	e
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-28	-0.1032190.410599	0.144044	1.454274	0.0 <-요기에 들어감
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-10-31	-2.5529900.653619	0.864436	-0.7421650.0 <-요기에 들어감
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0
2022-11-02	-0.887786-1.980796-0.3479120.156349	8.0

df3['e'].describe()
# var는 분산, std는 표준편차
출력
count    6.000000
mean     4.500000
std      2.738613
min      1.000000
25%      2.500000
50%      4.500000
75%      6.500000
max      8.000000
Name: e, dtype: float64

df3.sum()   # df3.sum(axis=0) 하고 같다, axis=0를 쓰나 안쓰나 같다
출력
a     4.612487
b    -3.031549
c     3.392083
d     2.250388
e    27.000000
dtype: float64

df3.sum(axis=1)  
# 연도 별로 합이 된다
출력
2022-10-26    6.383841 (a+b+c+d+e)
2022-10-27    3.689011
2022-10-28    1.905697
2022-10-29    5.660250
2022-10-30    5.747893
2022-10-31   -1.777100
2022-11-01    7.673964
2022-11-02    4.939855
Freq: D, dtype: float64


dates = df3.index
rnd_dates = np.random.permutation(dates)
print(rnd_dates)

df4 = df3.reindex(index=rnd_dates, columns=['e', 'a', 'c', 'd', 'b'])
df4
# reindex 다시 지정한 순서대로 하겟다는 의미
출력
['2022-11-02T00:00:00.000000000' '2022-11-01T00:00:00.000000000'
 '2022-10-26T00:00:00.000000000' '2022-10-28T00:00:00.000000000'
 '2022-10-27T00:00:00.000000000' '2022-10-30T00:00:00.000000000'
 '2022-10-31T00:00:00.000000000' '2022-10-29T00:00:00.000000000']

	             e	a	c	d	b
2022-11-02	8.0	-0.887786-0.3479120.156349	-1.980796
2022-11-01	7.0	2.269755	0.045759	-0.187184-1.454366
2022-10-26	1.0	1.764052	0.978738	2.240893	0.400157
2022-10-28	NaN	-0.1032190.144044	1.454274	0.410599
2022-10-27	2.0	1.867558	0.950088	-0.151357-0.977278
2022-10-30	5.0	1.494079	0.313068	-0.854096-0.205158
2022-10-31	NaN	-2.5529900.864436	-0.7421650.653619
2022-10-29	4.0	0.761038	0.443863	0.333674	0.121675

# 날짜 순서대로 나열해 주면서 행전체가 같이 움직임
df4.sort_index()  # df4.sort_index(axis=0) 하고 같다 
출력
	            e	a	c	d	b
2022-10-26	1.0	1.764052	0.978738	2.240893	0.400157
2022-10-27	2.0	1.867558	0.950088	-0.151357-0.977278
2022-10-28	NaN	-0.1032190.144044	1.454274	0.410599
2022-10-29	4.0	0.761038	0.443863	0.333674	0.121675
2022-10-30	5.0	1.494079	0.313068	-0.854096-0.205158
2022-10-31	NaN	-2.5529900.864436	-0.7421650.653619
2022-11-01	7.0	2.269755	0.045759	-0.187184-1.454366
2022-11-02	8.0	-0.887786-0.3479120.156349	-1.980796

# 컬럼을 순서대로 나열해 주면서 마찬가지로 열 전체가 같이 움직임
df4.sort_index(axis=1)
출력
                           a	   b	   c	  d	e
2022-11-02	-0.887786-1.980796-0.3479120.156349	8.0
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0
2022-10-28	-0.1032190.410599	0.144044	1.454274	NaN
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-10-31	-2.5529900.653619	0.864436	-0.742165NaN
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0

# 날짜가 오름차순으로 된다
df4.sort_index(axis=0, ascending=True)
출력
	             e	a	c	d	b
2022-10-26	1.0	1.764052	0.978738	2.240893	0.400157
2022-10-27	2.0	1.867558	0.950088	-0.151357-0.977278
2022-10-28	NaN	-0.1032190.144044	1.454274	0.410599
2022-10-29	4.0	0.761038	0.443863	0.333674	0.121675
2022-10-30	5.0	1.494079	0.313068	-0.854096-0.205158
2022-10-31	NaN	-2.5529900.864436	-0.7421650.653619
2022-11-01	7.0	2.269755	0.045759	-0.187184-1.454366
2022-11-02	8.0	-0.887786-0.3479120.156349	-1.980796

# 날짜가 내림차순으로 된다
df4.sort_index(axis=0, ascending=False)
출력
                       e	a	c	d	b
2022-11-02	8.0	-0.887786-0.3479120.156349	-1.980796
2022-11-01	7.0	2.269755	0.045759	-0.187184-1.454366
2022-10-31	NaN	-2.5529900.864436	-0.7421650.653619
2022-10-30	5.0	1.494079	0.313068	-0.854096-0.205158
2022-10-29	4.0	0.761038	0.443863	0.333674	0.121675
2022-10-28	NaN	-0.1032190.144044	1.454274	0.410599
2022-10-27	2.0	1.867558	0.950088	-0.151357-0.977278
2022-10-26	1.0	1.764052	0.978738	2.240893	0.400157

# 컬럼이 오름차순으로 된다
df4.sort_index(axis=1, ascending=True)
출력
	                a	  b	  c	  d	e
2022-11-02	-0.887786-1.980796-0.3479120.156349	8.0
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0
2022-10-28	-0.1032190.410599	0.144044	1.454274	NaN
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-10-31	-2.5529900.653619	0.864436	-0.742165NaN
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0

# 컬럼이 내림차순으로 된다
df4.sort_index(axis=1, ascending=False)
출력
	            e	d	c	b	a
2022-11-02	8.0	0.156349	-0.347912-1.980796-0.887786
2022-11-01	7.0	-0.1871840.045759	-1.4543662.269755
2022-10-26	1.0	2.240893	0.978738	0.400157	1.764052
2022-10-28	NaN	1.454274	0.144044	0.410599	-0.103219
2022-10-27	2.0	-0.1513570.950088	-0.9772781.867558
2022-10-30	5.0	-0.8540960.313068	-0.2051581.494079
2022-10-31	NaN	-0.7421650.864436	0.653619	-2.552990
2022-10-29	4.0	0.333674	0.443863	0.121675	0.761038

# df4를 날짜 인덱스는 내림차순, 컬럼은 오름차순 정렬시킨 후
# df5에 그 결과를 할당하시오
df5 = df4.sort_index(axis=0, ascending=False)
df5 = df5.sort_index(axis=1, ascending=True)
df5
출력
	                 a	  b	c	d	e
2022-11-02	-0.887786-1.980796-0.3479120.156349	8.0
2022-11-01	2.269755	-1.4543660.045759	-0.1871847.0
2022-10-31	-2.5529900.653619	0.864436	-0.742165NaN
2022-10-30	1.494079	-0.2051580.313068	-0.8540965.0
2022-10-29	0.761038	0.121675	0.443863	0.333674	4.0
2022-10-28	-0.1032190.410599	0.144044	1.454274	NaN
2022-10-27	1.867558	-0.9772780.950088	-0.1513572.0
2022-10-26	1.764052	0.400157	0.978738	2.240893	1.0

# 날짜 인덱스는 오름차순, 컬럼은 내림차순으로 정렬
# df6에 할당하기
df6 = df5.sort_index(axis=0, ascending=True)
df6 = df6.sort_index(axis=1, ascending=False)
df6
출력
	            e	d	c	b	a
2022-10-26	1.0	2.240893	0.978738	0.400157	1.764052
2022-10-27	2.0	-0.1513570.950088	-0.9772781.867558
2022-10-28	NaN	1.454274	0.144044	0.410599	-0.103219
2022-10-29	4.0	0.333674	0.443863	0.121675	0.761038
2022-10-30	5.0	-0.8540960.313068	-0.2051581.494079
2022-10-31	NaN	-0.7421650.864436	0.653619	-2.552990
2022-11-01	7.0	-0.1871840.045759	-1.4543662.269755
2022-11-02	8.0	0.156349	-0.347912-1.980796-0.887786
​
알아보기 쉽게 바꾸기
df5['a'] = [1, 2, 3, 4, 5, 6, 7, 8]
df5
출력
                       e	a	c	b	d
2022-10-27	2.0	1	0.950088	-0.977278-0.151357
2022-10-28	NaN	2	0.144044	0.410599	1.454274
2022-10-30	5.0	3	0.313068	-0.205158-0.854096
2022-11-01	7.0	4	0.045759	-1.454366-0.187184
2022-10-26	1.0	5	0.978738	0.400157	2.240893
2022-10-31	NaN	6	0.864436	0.653619	-0.742165
2022-11-02	8.0	7	-0.347912-1.9807960.156349
2022-10-29	4.0	8	0.443863	0.121675	0.333674

# a 값들이 내림차순으로 정렬되며, b,c,d,e 값들도 똑같이 움직인다, 
# 즉 행 단위로 같이 움직인다는걸 알아야한다.
df5.sort_values(by='a', ascending=False)
출력
	            e	a	c	b	d
2022-10-29	4.0	8	0.443863	0.121675	0.333674
2022-11-02	8.0	7	-0.347912-1.9807960.156349
2022-10-31	NaN	6	0.864436	0.653619	-0.742165
2022-10-26	1.0	5	0.978738	0.400157	2.240893
2022-11-01	7.0	4	0.045759	-1.454366-0.187184
2022-10-30	5.0	3	0.313068	-0.205158-0.854096
2022-10-28	NaN	2	0.144044	0.410599	1.454274
2022-10-27	2.0	1	0.950088	-0.977278-0.151357










































































































































































































































































































